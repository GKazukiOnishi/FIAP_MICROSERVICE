Docker
	1 - Criar um Banco de Dados em Container 
		Volume e gerenciamento de arquivos
	2 - Criar um Proxy Reverso
		Redes
	
	Por que usar?
		Resolve o na minha máquina funciona
			Porque customizamos o nosso ambiente, com imagens e containers todos são iguais e as dependências são iguais nos ambientes
		Image é o artefato que especifica como os containers devem ser criados, incluindo a versão do SO, libs, binários da aplicação
		
	Docker fluxo
		Dockerfile ->build-> Docker Image ->run-> Docker Container
		
		Dockerfile permite extender outros, então vc pode criar do zero ou partir de outras base
		
	JDK -> Java Development Kit
	JRE -> Java Runtime Enviroment
	
	O Dockerfile é o item do desenvolvedor, configura o que é necessário, usuários, pastas, copia coisas pra dentro
	Dockerfile é compilado para gerar a imagem (se tiver configurado com coisas do seu PC, vai compilar errado em outros dependendo)
	Dockerfile compilado precisa ser versionado, já que o dockerfile pode evoluir conforme a aplicação evolui
	Essas imagens podem ser colocadas em repositórios, tipo o Maven
	
	Nisso quando alguém precisa baixa essa imagem e então roda para gerar um Container
	
	Docker image - Ex:
		FROM scratch
		ADD alpine-minirootfs-3.18.3-x86_64.tar.gz /
		CMD ["/bin/sh"]
	
	alpine -> SO com menos de 5 Mb (só isso)
	Quanto maior a imagem mais tempo para fazer download, então demora mais para subir a aplicação no ar
	
	Docker Image - Tags
		Imagens suportam versionamento por tags
		Cada tag pode indicar uma versão diferente de compilação, tecnologia, arquitetura de computador
		
		DevOps
			Dev commitando com sua assinatura (nome, email e assinatura (para garantir que é vc mesmo))
			push
			Repositório Git recebendo o commit
			CI (Continuous Integration) entra em ação
				Podem ter ferramentas para checagem
					Sonar -> faz críticas para quebrar o build em caso de má práticas
					Análise de segurança -> checagem de vulnerabilidades de dependências
					Testes sendo executados
				Build feito (mvn build)
				Compilação da imagem docker (docker build)
			CD (Continuous Deployment) entra em ação
				Com a nova imagem o processo implanta ela no servidor
				Execução de scripts de banco de dados
			Servidor recebe aplicação e inicia execução
	
		Nisso temos muito interesse no versionamento, porque para cada commit podemos ter uma diferente
		Para cada arquitetura, cada tecnologia usada etc.
	
	Até banco de dados, por que?
		Porque nos testes de banco de dados geralmente não dá certo rodar várias vezes
		Então podemos rapidamente subir e destruir ele
		Para cache também, mesma ideia, testamos e destruímos
		
		Já em produção é outra coisa, lá você não vai subir e destruir o banco de produção
	
	Volume de docker -> Link simbólico
		Acessam a pasta mapeada diretamente
	
	Disponibilidade
		Se o mapeamento estiver fixo, se trocar de máquina não vai dar certo a não ser que tenha o mesmo arquivo na mesma pasta
		Então um jeito é mapear na rede
		E se a rede cair? Aí vai pensando cada vez mais em pontos de disponibilidade
	
	Comandos
		docker pull <nome da imagem>
		docker pull mysql
		docker pull mysql:latest
		
		\-> comando para baixar a imagem
		
		docker run --name {nomeImagem} -e MYSQL_ROOT_PASSWORD={senhaBanco} -d mysql:tag
		docker run --name bd -e MYSQL_ROOT_PASSWORD=abc -d mysql
		
		user -> root
		
		\-> comando para rodar uma imagem e gerar container com {nomeContainer} passando como variável de ambiente a MYSQL_ROOT_PASSWORD
			Rodando sem bloquear o terminal, e usando a imagem mysql:tag
		
		docker image ls
		
		\-> para ver as imagens baixadas
		
		docker imagem rm {nomeImagem}
		
		\-> remove uma imagem
		
		docker ps
		
		\-> ver containers
		
		docker run --name phpmyadmin -d -e MYSQL_ROOT_PASSWORD=abc --link {nomeContainer}:db -p 8080:80 phpmyadmin
		
		\-> --link para conectar os containers, possibilitando que o container do mysql conecte com do phpmyadmin pela porta
		
		
		
		rodando phpMyAdmin
		
		docker run --name phpmyadmin -d -e MYSQL_ROOT_PASSWORD=abc --link {nomeContainer}:db -p 8080:80 phpmyadmin
		
		
		
		docker rm {nomeContainer}
		docker stop {nomeContainer}
		docker start {nomeContainer}
		
		
		docker run --help -> mostra opções que pode usar com o docker run
		
		docker run --name srv-mysql -v C:\Projetos\MySql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=SENA-SUPER-FORTE -d mysql
		
		\-> -v {pastaNaMáquina}:{pastaNoContainer} para mapear uma pasta da máquina com o container, nisso apagando o container os dados do banco mantém
		
		docker run --name srv-mysql -v C:\Projetos\MySql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=SENA-SUPER-FORTE -p 3306:3306 -d mysql
		
		\-> com a exposição da porta pelo -p agora dá para acessar o banco na máquina
		
		
	Proxy Reverso
		
		Se subirmos dois containers na porta 80, não dá muito certo
		Só uma pode usar por vez
		
		Proxy Reverso é um app webserver que vai estar à frente das outras
		Ele vai se conectar ao 80 e os outros vão se conectar a ele
		E a partir de contexto da url ele vai diferenciar as aplicações
		
		http://localhost:80/app1
		http://localhost:80/app2
		
		WAF -> Web Application Firewall
		Ajuda a evitar SQL injection e outros problemas de segurança
		
			http://localhost:80/app1?name=jose''or 1=1'...
			
			A query do banco fica
			SELECT * FROM USUARIOS WHERE NAME='jose' OR 1 = 1;
			Nisso ele consegue buscar todos os usuários por exemplo
			
		WAF consegue impedir isso, detectando strings estranhas
		Ele vira um intermédio que consegue analisar o que entra
		Vira um ponto único de entrada
		E ele que redireciona para os outros apps
		
	cmd
	mkdir nomePasta nomeOutraPasta
		
	Criar as pastas de volume:
	mkdir C:\Projetos\App1
	mkdir C:\Projetos\App2

	Cria o arquivo index.html para o app 1
	echo "<html><h1>App 1</h1><html/>" >>  C:\Projetos\App1\index.html 

	Cria o arquivo index.html para o app 2
	echo "<html><h1>App 2</h1><html/>" >>  C:\Projetos\App2\index.html 
	
	Cria a app1
	docker run --name app1 -v C:\Projetos\App1\:/usr/share/nginx/html:ro -d nginx

	Cria a app2
	docker run --name app2 -v C:\Projetos\App2\:/usr/share/nginx/html:ro -d nginx

	Cria a pasta para arquivo de configuração do proxi reverso
	mkdir C:\Projetos\ProxyReverso

	Cria o arquivo de configuração do proxy reverso

echo "upstream app1 {
  server        app1:80;
}
upstream app2 {
  server        app1:80;
}
server {
  listen        80;
  location /app1 {
    proxy_pass  http://app1;
  }
  location /app2 {
	proxy_pass  http://app2;
  }
}" >>  C:\Projetos\ProxyReverso\proxy.conf

	Cria o container para servir de proxy reverso
	docker run --name proxy -v C:\Projetos\ProxyReverso\proxy.conf:/etc/nginx/nginx.conf:ro -p 80:80 -d nginx

	Cria uma rede
	docker network create vnet-apps

	Conecta o container app1 à rede
	docker network connect vnet-apps app1

	Conecta o container app2 à rede
	docker network connect vnet-apps app2

	Conecta o container proxy à rede
	docker network connect vnet-apps proxy 